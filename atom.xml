<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>依禅 - 个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fox-z.github.io/"/>
  <updated>2020-09-21T08:26:41.175Z</updated>
  <id>https://fox-z.github.io/</id>
  
  <author>
    <name>yichan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>puppeteer实践</title>
    <link href="https://fox-z.github.io/2020/09/10/puppeteer%E5%AE%9E%E8%B7%B5/"/>
    <id>https://fox-z.github.io/2020/09/10/puppeteer实践/</id>
    <published>2020-09-10T02:41:37.000Z</published>
    <updated>2020-09-21T08:26:41.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="puppeteer简单介绍"><a href="#puppeteer简单介绍" class="headerlink" title="puppeteer简单介绍"></a>puppeteer简单介绍</h2><p>英 [ˌpʌpɪˈtɪə(r)]</p><ul><li><p>Puppeteer 是 Node.js 工具引擎</p></li><li><p>Puppeteer 提供了一系列 API，通过 Chrome DevTools Protocol 协议控制 Chromium/Chrome 浏览器的行为</p></li><li><p>Puppeteer 默认情况下是以 headless 启动 Chrome 的，也可以通过参数控制启动有界面的 Chrome</p></li><li><p>Puppeteer 默认绑定最新的 Chromium 版本，也可以自己设置不同版本的绑定</p></li><li><p>Puppeteer 让我们不需要了解太多的底层 CDP 协议实现与浏览器的通信</p></li><li><p>Puppeteer API 是分层次的，反映了浏览器结构。</p><ul><li>Browser 实例可以拥有浏览器上下文。</li><li>BrowserContext 实例定义了一个浏览会话并可拥有多个页面。</li><li>Page 至少有一个框架：主框架。 可能还有其他框架由 iframe 或 框架标签 创建。</li><li>frame 至少有一个执行上下文 – 默认的执行上下文 – 框架的 JavaScript 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。</li><li>Worker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。</li></ul></li></ul><p>中文官网地址: <a href="https://www.mofazhuan.com/puppeteer-doc-zh#puppeteerlaunchoptions" target="_blank" rel="noopener">https://www.mofazhuan.com/puppeteer-doc-zh#puppeteerlaunchoptions</a><br>github: <a href="https://github.com/puppeteer/puppeteer" target="_blank" rel="noopener">https://github.com/puppeteer/puppeteer</a></p><h2 id="puppeteer的能力"><a href="#puppeteer的能力" class="headerlink" title="puppeteer的能力"></a>puppeteer的能力</h2><ul><li>网页截图或者生成 PDF</li><li>爬取网站（SPA 或 SSR）</li><li>UI 自动化测试，模拟表单提交，键盘输入，点击等行为</li><li>捕获网站的时间线，帮助诊断性能问题</li><li>创建一个最新的自动化测试环境，使用最新的 js 和最新的 Chrome 浏览器运行测试用例</li><li>测试 Chrome 扩展程序</li></ul><h2 id="安装puppeteer"><a href="#安装puppeteer" class="headerlink" title="安装puppeteer"></a>安装puppeteer</h2><p>其实puppeteer是 Chromium+API 的合体，下载的时候需要注意 Chromium 是否正常安装，如若不行则手动下载。服务器上尝试多次都无法正常下载，所以最好手动下载好服务器支持的版本，直接复制过去。</p><p>下载地址：<a href="https://npm.taobao.org/mirrors/chromium-browser-snapshots/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromium-browser-snapshots/</a></p><p>不同的系统安装不同的chrome，推荐安装版本：782078</p><h2 id="创建一个浏览器实例"><a href="#创建一个浏览器实例" class="headerlink" title="创建一个浏览器实例"></a>创建一个浏览器实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import puppeteer from &#39;puppeteer&#39;;</span><br><span class="line"></span><br><span class="line">(async () &#x3D;&gt; &#123;</span><br><span class="line">  const browser &#x3D; await puppeteer.launch(&#123;</span><br><span class="line">    &#x2F;&#x2F; 无头模式 指不打开浏览器窗口</span><br><span class="line">    headless: true, &#x2F;&#x2F; 是否以 无头模式 运行浏览器 false 打开浏览器，设置 true 不打开 无头浏览器</span><br><span class="line">    args: [</span><br><span class="line">      &#39;--no-sandbox&#39;, &#x2F;&#x2F; 如果没有可用于Chrome的优质沙箱，它将因错误崩溃，如果您完全信任在Chrome中打开的内容，则可以使用以下--no-sandbox参数启动Chrome</span><br><span class="line">      &#39;–single-process&#39;, &#x2F;&#x2F; Dom解析和渲染放到同一进程</span><br><span class="line">      &#39;–disable-gpu&#39;, &#x2F;&#x2F; disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算</span><br><span class="line">      &#39;–disable-dev-shm-usage&#39;, &#x2F;&#x2F; 禁止使用 &#x2F;dev&#x2F;shm 共享内存 (Chrome 默认使用 &#x2F;dev&#x2F;shm 共享内存docker 默认&#x2F;dev&#x2F;shm 只有64MB)</span><br><span class="line">      &#39;–disable-setuid-sandbox&#39;, &#x2F;&#x2F; Disable the setuid sandbox (Linux only). ↪</span><br><span class="line">      &#39;–no-first-run&#39;, &#x2F;&#x2F; 跳过第一次运行任务</span><br><span class="line">      &#39;–no-zygote&#39;, &#x2F;&#x2F; 禁止使用合子进程来分叉子进程</span><br><span class="line">    ],</span><br><span class="line">    ignoreDefaultArgs: [ &#39;--disable-extensions&#39; ], &#x2F;&#x2F; 扩展程序</span><br><span class="line">    defaultViewport: &#123;</span><br><span class="line">      width: 800, &#x2F;&#x2F; 页面宽度像素。建议不超过1000px，会有崩溃的情况</span><br><span class="line">      height: 800, &#x2F;&#x2F; &lt;number&gt; 页面高度像素。</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 打开一个了浏览器tab</span><br><span class="line">  const page &#x3D; await browser.newPage();</span><br><span class="line">  &#x2F;&#x2F; 在tab中打开百度官网</span><br><span class="line">  await page.goto(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;);</span><br><span class="line">  &#x2F;&#x2F; 关闭tab</span><br><span class="line">  await page.close();</span><br><span class="line">  &#x2F;&#x2F; 关闭浏览器</span><br><span class="line">  await browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="做个简单的应用实战示例，激起你们的兴趣"><a href="#做个简单的应用实战示例，激起你们的兴趣" class="headerlink" title="做个简单的应用实战示例，激起你们的兴趣"></a>做个简单的应用实战示例，激起你们的兴趣</h2><blockquote><p>抓取阮一峰es6这本电子书，生成pdf文档</p></blockquote><p>代码展示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下为egg代码</span><br><span class="line"></span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">const Controller &#x3D; require(&#39;egg&#39;).Controller;</span><br><span class="line">const Response &#x3D; require(&#39;..&#x2F;..&#x2F;extend&#x2F;response&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pdf页脚</span><br><span class="line">const footerTemplate &#x3D;</span><br><span class="line">  &#96;&lt;div</span><br><span class="line">    style&#x3D;&quot;width:80%;margin:0 auto;font-size: 8px;padding:10px 0;display: flex; justify-content: space-between; &quot;&gt;</span><br><span class="line">    &lt;span style&#x3D;&quot;&quot;&gt;页码&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;div&gt;&lt;span class&#x3D;&quot;pageNumber&quot;&gt;</span><br><span class="line">    &lt;&#x2F;span&gt; &#x2F; &lt;span class&#x3D;&quot;totalPages&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pdf页眉</span><br><span class="line">const headerTemplate &#x3D;</span><br><span class="line">  &#96;&lt;div</span><br><span class="line">    style&#x3D;&quot;width:80%;margin:0 auto;font-size: 8px;padding:10px 0;display: flex; justify-content: space-between;&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;;</span><br><span class="line"></span><br><span class="line">const defaultOptions &#x3D; &#123;</span><br><span class="line">  displayHeaderFooter: false,</span><br><span class="line">  &#x2F;&#x2F; headerTemplate,</span><br><span class="line">  &#x2F;&#x2F; footerTemplate,</span><br><span class="line">  format: &#39;A4&#39;,</span><br><span class="line">  margin: &#123;</span><br><span class="line">    top: &#39;20px&#39;,</span><br><span class="line">    bottom: &#39;20px&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ExampleController extends Controller &#123;</span><br><span class="line">  sleep(time) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          resolve(1);</span><br><span class="line">        &#125;, time);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        reject(0)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  async index() &#123;</span><br><span class="line">    const &#123; ctx, app, config &#125; &#x3D; this;</span><br><span class="line">    const &#123; baseDir, localImgDir&#125; &#x3D; config;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 生成单号对应的文件，便于操作pdf文件</span><br><span class="line">      const es6FileName &#x3D; path.join(baseDir, localImgDir, &#39;es6&#39;);</span><br><span class="line">      if (!fs.existsSync(es6FileName)) &#123;</span><br><span class="line">        fs.mkdirSync(es6FileName);</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.runInBackground(async () &#x3D;&gt; &#123;</span><br><span class="line">        await app.pagePool.use(async page &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 前往es6网站</span><br><span class="line">          await page.goto(&#39;https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;&#39;, &#123;</span><br><span class="line">            waitUntil: &#39;load&#39;,</span><br><span class="line">          &#125;);</span><br><span class="line">          await this.sleep(2000);</span><br><span class="line">          let linkTags &#x3D; await page.evaluate(() &#x3D;&gt; &#123;</span><br><span class="line">            let aArrs &#x3D; [...document.querySelectorAll(&#39;#sidebar ol li a&#39;)];</span><br><span class="line">            return aArrs.map((aTag) &#x3D;&gt; &#123;</span><br><span class="line">              return &#123;</span><br><span class="line">                href: aTag.href,</span><br><span class="line">                name: aTag.text</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">          ctx.logger.info(&#39;打印目录linkTags&#39;, linkTags);</span><br><span class="line">          for(let i &#x3D; 0, len &#x3D; linkTags.length; i &lt; len; i++) &#123;</span><br><span class="line">            const pdfItem &#x3D; linkTags[i];</span><br><span class="line">            const pdfOutPath &#x3D; path.join(baseDir, localImgDir, &#39;es6&#39;, &#96;$&#123;i&#125;.$&#123;pdfItem.name&#125;.pdf&#96;);</span><br><span class="line">            await page.goto(pdfItem.href, &#123;</span><br><span class="line">              waitUntil: &#39;load&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">            await this.sleep(4000);</span><br><span class="line">            ctx.logger.info(&#39;打印中++++&#39;, pdfOutPath);</span><br><span class="line">            await page.pdf(&#123;</span><br><span class="line">              ...defaultOptions,</span><br><span class="line">              path: pdfOutPath,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          ctx.logger.info(&#39;生成成功++++&#39;);</span><br><span class="line">          return;</span><br><span class="line">        &#125;, ctx);</span><br><span class="line">      &#125;);</span><br><span class="line">      Response.SUCCESS(ctx, &#39;成功&#39;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      Response.SYSTEMERR(ctx, err);</span><br><span class="line">      ctx.logger.error(&#39;es6-ExampleController-errow&#39;, err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; ExampleController;</span><br></pre></td></tr></table></figure><h2 id="两个独立的环境"><a href="#两个独立的环境" class="headerlink" title="两个独立的环境"></a>两个独立的环境</h2><p>在使用 Puppeteer 时我们几乎一定会遇到在这两个环境之间交换数据：运行 Puppeteer 的 Node.js 环境和 Puppeteer 操作的页面 Page DOM，理解这两个环境很重要</p><p>首先 Puppeteer 提供了很多有用的函数去 Page DOM Environment 中执行代码<br>其次 Puppeteer 提供了 ElementHandle 和 JsHandle 将 Page DOM Environment 中元素和对象封装成对应的 Node.js 对象，这样可以直接这些对象的封装函数进行操作 Page DOM</p><p><img src="http://bw-online-img.oss-cn-hangzhou.aliyuncs.com/v2-19fd26d4146347055c324158efa40eb7_720w.jpg" alt="example" title="layout"></p><h2 id="在项目中的使用"><a href="#在项目中的使用" class="headerlink" title="在项目中的使用"></a>在项目中的使用</h2><ul><li>启动配置</li></ul><p>默认开启一个浏览器，10个tab页面，维护在一个池子里，每次用到的时候，去池子里拿到空闲的那个tab页，去执行业务。</p><p>q: 为啥不是用到的时候再打开一个浏览器，一个tab页，使用后就关闭？<br>q: 为什么启动的时候打开这么多？<br>q: 打开的这么多的页面会带来什么其他问题?</p><ul><li>生成实时分享图片（截图功能）</li></ul><p>上一段官网示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer &#x3D; require(&#39;puppeteer&#39;);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(async browser &#x3D;&gt; &#123;</span><br><span class="line">  const page &#x3D; await browser.newPage();</span><br><span class="line">  await page.goto(&#39;https:&#x2F;&#x2F;baidu.com&#39;);</span><br><span class="line">  await page.screenshot(&#123;path: &#39;screenshot.png&#39;&#125;);</span><br><span class="line">  await browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：官网示例并不能直接生产使用，包括第三方代码(github)。</p><p>具体看项目代码，顺便review一下</p><ul><li>导出发货单（生成pdf功能）</li></ul><p><strong>首先不管是本地开发，还是线上服务器都需要安装pdftk</strong></p><ul><li>服务器缺少pdftk应用，需要下载安装</li></ul><ul><li>yum install gcc gcc-c++ libXrandr gtk2 libXtst libart_lgpl</li><li>wget  <a href="http://mirror.centos.org/centos/6/os/x86_64/Packages/libgcj-4.4.7-23.el6.x86_64.rpm" target="_blank" rel="noopener">http://mirror.centos.org/centos/6/os/x86_64/Packages/libgcj-4.4.7-23.el6.x86_64.rpm</a><br>完成后执行：rpm -ivh –nodeps libgcj-4.4.7-23.el6.x86_64.rpm</li><li>wget <a href="https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/pdftk-2.02-1.el6.x86_64.rpm" target="_blank" rel="noopener">https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/pdftk-2.02-1.el6.x86_64.rpm</a><br>完成后执行：yum install pdftk-2.02-1.el6.x86_64.rpm</li><li>测试是否安装成功,能正常打印路径即可<br>which pdftk</li></ul><p>本项目中只用到了pdftk中的合并pdf的功能，其他强大的功能并未使用到。</p><p>具体看项目代码，顺便review一下</p><h2 id="服务器上遇到的坑"><a href="#服务器上遇到的坑" class="headerlink" title="服务器上遇到的坑"></a>服务器上遇到的坑</h2><ul><li><p>Chromium安装问题<br>在服务器上需要先安装依赖项，以及chrome<br>centOS:</p><ul><li><p>依赖库<br><code>yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</code></p></li><li><p>字体<br><code>yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y</code></p></li><li><p>安装完成后 更新nss library<br><code>yum update nss -y</code></p></li></ul></li><li><p>字体库支持问题<br>推荐中日韩字体，一般服务器上字体不多，字体有乱码的情况，需要自己下载合适的字体</p></li><li><p>内存以及cpu资源的权衡<br>批量生成图片或者pdf需要大量的文件操作，对cpu和内存都是考验，服务器上需要运维人员合理分配资源，本地开发多关注cpu和内存的损耗，有不合理的及时优化，避免上线后把服务器弄炸了。</p></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li><p>几个核心启动项</p><ul><li>headless: true, // 是否以 无头模式 运行浏览器 false 打开浏览器，设置 true 不打开 无头浏览器</li><li>args: [<br>  ‘–no-sandbox’, // 如果没有可用于Chrome的优质沙箱，它将因错误崩溃，如果您完全信任在Chrome中打开的内容，则可以使用以下–no-sandbox参数启动Chrome<br>  ‘–single-process’, // Dom解析和渲染放到同一进程<br>  ‘–disable-gpu’, // disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算<br>  ‘–disable-dev-shm-usage’, // 禁止使用 /dev/shm 共享内存 (Chrome 默认使用 /dev/shm 共享内存docker 默认/dev/shm 只有64MB)<br>  ‘–disable-setuid-sandbox’, // Disable the setuid sandbox (Linux only). ↪<br>  ‘–no-first-run’, // 跳过第一次运行任务<br>  ‘–no-zygote’, // 禁止使用合子进程来分叉子进程<br>],</li><li>ignoreDefaultArgs: [ ‘–disable-extensions’ ], // 扩展程序</li></ul><p>说明：</p><ul><li>推荐在本地或者服务器都开启无头模式，headless: true，原因有下：1.无头模式服务器才支持 2.无头模式才能生成pdf</li><li>args启动项涉及到非常庞大的知识体系，其中的参数可大大节省启动时间，加快启动速度，以及避开一些服务器上的限制，具体可参考 <a href="https://peter.sh/experiments/chromium-command-line-switches/" target="_blank" rel="noopener">https://peter.sh/experiments/chromium-command-line-switches/</a></li><li>ignoreDefaultArgs参数 配置 –disable-extensions 为禁用扩展程序，建议添加</li></ul></li><li><p>连接池</p><p>代码示例：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const puppeteer &#x3D; require(&#39;puppeteer-core&#39;);</span><br><span class="line">&#x2F;&#x2F; const Response &#x3D; require(&#39;..&#x2F;app&#x2F;extend&#x2F;response&#39;);</span><br><span class="line"></span><br><span class="line">class Pool &#123;</span><br><span class="line"></span><br><span class="line">  constructor(browserMax, pageMax, chromePath) &#123;</span><br><span class="line">    this.browsers &#x3D; [];</span><br><span class="line">    this.browserMax &#x3D; browserMax;</span><br><span class="line">    this.pageMax &#x3D; pageMax;</span><br><span class="line">    this.chromePath &#x3D; chromePath;</span><br><span class="line">    this.useCount &#x3D; 100;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createAll() &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123;</span><br><span class="line">      let browser &#x3D; await this.createBrowser();</span><br><span class="line">      this.browsers[i] &#x3D; &#123; browser, pages: []&#125;;</span><br><span class="line">      let [defaultPage] &#x3D; await browser.pages();</span><br><span class="line">      &#x2F;&#x2F; defaultPage &#x3D; await this.setPage(defaultPage);</span><br><span class="line">      this.browsers[i].pages[0] &#x3D; &#123;</span><br><span class="line">        page: defaultPage,</span><br><span class="line">        used: false,</span><br><span class="line">        count: 0,</span><br><span class="line">        browser</span><br><span class="line">      &#125;;</span><br><span class="line">      for (var k &#x3D; 1; k &lt; this.pageMax; k++) &#123;</span><br><span class="line">        let page &#x3D; await this.createPage(browser);</span><br><span class="line">        this.browsers[i].pages[k] &#x3D; &#123;</span><br><span class="line">          page,</span><br><span class="line">          used: false,</span><br><span class="line">          count: 0,</span><br><span class="line">          browser</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.browsers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createBrowser(w, h) &#123;</span><br><span class="line">    let browser &#x3D; await puppeteer.launch(&#123;</span><br><span class="line">      headless: true,</span><br><span class="line">      ignoreHTTPSErrors: true,</span><br><span class="line">      args: [</span><br><span class="line">        &#39;--no-sandbox&#39;, &#x2F;&#x2F; 如果没有可用于Chrome的优质沙箱，它将因错误崩溃，如果您完全信任在Chrome中打开的内容，则可以使用以下--no-sandbox参数启动Chrome</span><br><span class="line">        &#39;–single-process&#39;, &#x2F;&#x2F; Dom解析和渲染放到同一进程</span><br><span class="line">        &#39;–disable-gpu&#39;, &#x2F;&#x2F; disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算</span><br><span class="line">        &#39;–disable-dev-shm-usage&#39;,</span><br><span class="line">        &#39;–disable-setuid-sandbox&#39;,</span><br><span class="line">        &#39;–no-first-run&#39;,</span><br><span class="line">        &#39;–no-zygote&#39;</span><br><span class="line">      ],</span><br><span class="line">      ignoreDefaultArgs: [&#39;--disable-extensions&#39;],</span><br><span class="line">      defaultViewport: &#123;</span><br><span class="line">        width: w || 800, &#x2F;&#x2F; 页面宽度像素。不能超过1000px，会有崩溃的情况</span><br><span class="line">        height: h || 800, &#x2F;&#x2F; &lt;number&gt; 页面高度像素。</span><br><span class="line">      &#125;,</span><br><span class="line">      executablePath: path.resolve(this.chromePath),</span><br><span class="line">    &#125;);</span><br><span class="line">    return browser;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createPage(browser) &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用默认的就是PC 的 devices</span><br><span class="line">    &#x2F;&#x2F; const devices &#x3D; require(&quot;puppeteer&#x2F;DeviceDescriptors&quot;);</span><br><span class="line">    &#x2F;&#x2F; const iPhonex &#x3D; devices[&quot;iPhone X&quot;];</span><br><span class="line">    let page &#x3D; await browser.newPage();</span><br><span class="line">    &#x2F;&#x2F; page &#x3D; await setPage(page);</span><br><span class="line">    return page;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async setPage(page) &#123;</span><br><span class="line">    await page.setViewport(&#123;</span><br><span class="line">      width: 800,</span><br><span class="line">      height: 800</span><br><span class="line">    &#125;);</span><br><span class="line">    await page.setRequestInterception(true);</span><br><span class="line">    return page;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async use(func, ctx) &#123;</span><br><span class="line">    let item &#x3D; await this._findFreePage();</span><br><span class="line">    let ret;</span><br><span class="line">    if (item) &#123;</span><br><span class="line">      item.used &#x3D; true;</span><br><span class="line">      item.count++;</span><br><span class="line">      try &#123;</span><br><span class="line">        ret &#x3D; await func(item.page);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        ret &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">      if (item.count &gt;&#x3D; this.useCount) &#123;</span><br><span class="line">        await item.page.close();</span><br><span class="line">        item.page &#x3D; await this.createPage(item.browser);</span><br><span class="line">        item.count &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      item.used &#x3D; false;</span><br><span class="line">      return ret;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 没有拿到空闲的page 临时新建一个用完关闭</span><br><span class="line">      let page &#x3D; await this.createPage(this.browsers[0].browser);</span><br><span class="line">      try &#123;</span><br><span class="line">        ret &#x3D; await func(page);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        ret &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">      await page.close();</span><br><span class="line">      return ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async _findFreePage() &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123;</span><br><span class="line">      for (var k &#x3D; 0; k &lt; this.pageMax; k++) &#123;</span><br><span class="line">        let item &#x3D; this.browsers[i].pages[k];</span><br><span class="line">        if (item.used &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">          if (item.page.isClosed()) &#123;</span><br><span class="line">            item.page &#x3D; await this.createPage(this.browsers[i].browser);</span><br><span class="line">            item.count &#x3D; 0;</span><br><span class="line">          &#125;</span><br><span class="line">          this.browsers[i].pages.push(this.browsers[i].pages.splice(k, 1)[0]);</span><br><span class="line">          return item;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep (time) &#123;</span><br><span class="line">    return new Promise((res, rej) &#x3D;&gt; setTimeout(res, time))</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  async checkFree() &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123;</span><br><span class="line">      for (var k &#x3D; 0; k &lt; this.pageMax; k++) &#123;</span><br><span class="line">        if (this.browsers[i].pages[k].used) &#123;</span><br><span class="line">          await this.sleep(1000);</span><br><span class="line">          return this.checkFree();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async close() &#123;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123;</span><br><span class="line">      await this.browsers[i].browser.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; Pool</span><br></pre></td></tr></table></figure><p>  puppeteer做成一个服务，接口需要快速生成图片，往往在200ms就需要返回，通过配置连接池，可减少启动谷歌，打开新页面带来的时间消耗（基本400ms以上）,所以提升还是非常大的，另外连接池还能应对并发。<br>  缺点就是：服务器内存占用无法释放</p><ul><li><p>异常处理</p><p>浏览器或者页面都存在崩溃的情况，需要对这类情况进行处理，保证及时释放掉崩溃的程序占用的资源，缓解服务器压力。</p><p><code>GoogleBroswer.on(&#39;disconnected&#39;, this.closeBroswer);</code></p><p>浏览器提供了相应的监听方法，我们只需要控制好逻辑处理就行。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>puppeteer有谷歌作为后盾，技术实力可见一斑，社区支持基本够用</li><li>puppeteer作为生产图片,pdf等的技术方案要优于其他，具体小伙伴可以自行对比</li><li>功能强大，api支持度高，使用对前端友好</li><li>对大数据的生成任务，比较消耗服务器资源</li><li>文档介绍偏向入门，给人很强的信心，实际操作起来，步步受限</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;puppeteer简单介绍&quot;&gt;&lt;a href=&quot;#puppeteer简单介绍&quot; class=&quot;headerlink&quot; title=&quot;puppeteer简单介绍&quot;&gt;&lt;/a&gt;puppeteer简单介绍&lt;/h2&gt;&lt;p&gt;英 [ˌpʌpɪˈtɪə(r)]&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="FE" scheme="https://fox-z.github.io/categories/FE/"/>
    
    
      <category term="puppeteer" scheme="https://fox-z.github.io/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>Hooks基本用法</title>
    <link href="https://fox-z.github.io/2020/05/30/Hooks/"/>
    <id>https://fox-z.github.io/2020/05/30/Hooks/</id>
    <published>2020-05-30T06:16:54.000Z</published>
    <updated>2020-09-10T11:55:54.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p></blockquote><h2 id="hook规则"><a href="#hook规则" class="headerlink" title="hook规则"></a>hook规则</h2><ul><li>只在最顶层使用 Hook</li></ul><p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。简单的讲：react依赖hook定义的顺序，以便在每一次重渲染时都能准确更新状态.</p><ul><li>只在 React 函数中调用 Hook</li></ul><p>在 React 的函数组件中调用 Hook<br>在自定义 Hook 中调用其他 Hook</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>useState主要用来定义可以影响视图的变量</p><p>参数：initState 两种类型(any || () =&gt; {})<br>返回值：[a, setA]  (数组且只有两个参数)</p><blockquote><p>思考下为啥是一个数组？</p></blockquote><p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p><p>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [a, setA] &#x3D; useState(0);</span><br><span class="line">  &#x2F;&#x2F; const [a, setA] &#x3D; useState(() &#x3D;&gt; 0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;a&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用场景：定义组件内部的一些状态</p><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>参数：（reducerFunction, initState）<br>返回值：[a, dispatchA]  (数组且只有两个参数)</p><p>useReducer和useState一样主要用来定义可以影响视图的变量<br>useState底层用的还是useReducer，所以你任何时候可以使用useReducer代替useState</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [items, dispatch] &#x3D; useReducer((state, action) &#x3D;&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something with the action</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>主要使用场景：在useState的基础上，useReducer多了在父子组件通讯上的功能，比如可以直接向子组件传递一个dispatch 而不是 回调函数，另外在处理复杂逻辑时显然useReducer显得更加优雅。</p><p><strong>注意点</strong></p><p>对于引用类型的数据，例如数组。useState和useReducer都是不可以直接对变量（a）进行操作的，<br>必须切断引用关系，新值才会生效</p><p>解决方案：对于复杂数据类型 通用的方案是 immer use-immer, 使用useImmer替代useState 是更加合理的方案</p><p>qa:</p><p>当组件拥有多个 state 时，应该把多个 state 合并成一个 state ，还是把 state 切分成多个 state 变量？</p><p>要么把所有 state 都放在同一个 useState 调用中，要么每一个字段都对应一个 useState 调用，这两方式都能跑通。</p><p>当你在这两个极端之间找到平衡，然后把相关 state 组合到几个独立的 state 变量时，组件就会更加的可读。如果 state 的逻辑开始变得复杂，我们推荐用 useReducer 来管理它，或使用自定义 Hook。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>参数：(callback, []?)<br>返回值：可选  (componentWillUnmount)</p><p>useEffect 用来取代 componentDidMount , componentDidUpdate 和 componentWillUnmount。主要作用是当页面<strong>渲染后</strong>，进行一些副作用操作</p><blockquote><p>副作用：访问 DOM，请求数据，定时器，订阅消息。</p></blockquote><p>useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p><h3 id="每次-Render-都有自己的-Props-与-State"><a href="#每次-Render-都有自己的-Props-与-State" class="headerlink" title="每次 Render 都有自己的 Props 与 State"></a>每次 Render 都有自己的 Props 与 State</h3><p>可以认为每次 Render 的内容都会形成一个快照并保留下来，因此当状态变更而 Rerender 时，就形成了 N 个 Render 状态，而每个 Render 状态都拥有自己固定不变的 Props 与 State。</p><p>在每次点击时，count 只是一个不会变的常量，而且也不存在利用 Proxy 的双向绑定，只是一个常量存在于每次 Render 中。<br>初始状态下 count 值为 0，而随着按钮被点击，在每次 Render 过程中，count 的值都会被固化为 1、2、3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; During first render</span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count &#x3D; 0; &#x2F;&#x2F; Returned by useState()</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; After a click, our function is called again</span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count &#x3D; 1; &#x2F;&#x2F; Returned by useState()</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; After another click, our function is called again</span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count &#x3D; 2; &#x2F;&#x2F; Returned by useState()</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="几个用法"><a href="#几个用法" class="headerlink" title="几个用法"></a>几个用法</h3><ul><li>useEffect当作componentDidMount用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  const fetchData &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    const result &#x3D; await axios(</span><br><span class="line">      &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;,</span><br><span class="line">    );</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><ul><li>useEffect当作componentDidMount, componentDidUpdate用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  const fetchData &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    const result &#x3D; await axios(</span><br><span class="line">      &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;,</span><br><span class="line">    );</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData();</span><br><span class="line">&#125;, [page]);</span><br></pre></td></tr></table></figure><ul><li>useEffect当作componentDidMount, componentDidUpdate,componentWillUnmount用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line">  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  &#x2F;&#x2F; Specify how to clean up after this effect:</span><br><span class="line">  return function cleanup() &#123;</span><br><span class="line">    &#x2F;&#x2F; 清除订阅</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清除订阅在每次渲染都会执行，以确保老的视图不会对新视图造成副作用</span><br></pre></td></tr></table></figure><h3 id="性能优化建议："><a href="#性能优化建议：" class="headerlink" title="性能优化建议："></a>性能优化建议：</h3><ul><li>依赖项数组控制着 useEffect 的执行</li><li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可</li><li>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行</li><li>推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</li></ul><blockquote><blockquote><p>useEffect 不能接收 async 作为回调函数，useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise</p></blockquote></blockquote><blockquote><blockquote><p>在 useEffect 中调用用函数时，要把该函数在 useEffect 中申明，不能放到外部申明，然后再在 useEffect 中调用，你会想要在 effect 内部 去声明它所需要的函数。 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值</p></blockquote></blockquote><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p><img src="https://bw-online-img.oss-cn-hangzhou.aliyuncs.com/groupon/useLayout.jpeg" alt="useLayout" title="layout"></p><p>useLayoutEffect与useEffect作用比较相同 区别点在于执行的时机</p><ul><li>useEffect在全部渲染完毕后才会执行，useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行</li><li>可以使用它来读取 DOM 布局并同步触发重渲染</li><li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect</li><li>在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被同步刷新</li><li>尽可能使用标准的 useEffect 以避免阻塞视图更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function LayoutEffect() &#123;</span><br><span class="line">  const [color, setColor] &#x3D; useState(&#39;red&#39;);</span><br><span class="line">  useLayoutEffect(() &#x3D;&gt; &#123;</span><br><span class="line">      alert(color); &#x2F;&#x2F; 阻塞了渲染</span><br><span class="line">  &#125;);</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;color&#39;, color);</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&#123;&#123; background: color &#125;&#125;&gt;颜色&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;red&#39;)&#125;&gt;红&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;yellow&#39;)&#125;&gt;黄&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;blue&#39;)&#125;&gt;蓝&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>参数：(callback, []?)<br>返回值: function</p><p>接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新</p><p>第二个参数为依赖项，如果没有则每次都会执行返回值函数，为空数组，组件初始化的时候执行一次，后续 update 则取缓存里的，数组有依赖项，则在依赖项变更时触发useCallback。所以为了更好的性能，务必指定第二个参数</p><p>主要应用场景：父组件给子组件绑定方法，若非使用useCallback，则子组件在每次父组件render的时候都会重新渲染，推荐子组件搭配 React.memo 高阶函数一起使用。</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>参数：(callback, []?)<br>返回值: any</p><p>把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p><p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的</p><p>主要应用场景：熟悉Vue的同学可以把这个当作computed计算属性来理解，因此callback中最好指定return 项</p><h3 id="useCallback-与-useMemo-的异同点"><a href="#useCallback-与-useMemo-的异同点" class="headerlink" title="useCallback 与 useMemo 的异同点"></a>useCallback 与 useMemo 的异同点</h3><ul><li>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps), 最终的返回值都是一个 test 的memoized版本</li><li>useMemo更适合计算属性的场景，昂贵的计算 （购物车计算价格数量等）</li><li>useCallback更适合给组件绑定方法</li><li>useCallback返回的只能是函数，useMemo能返回多种类型</li></ul><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>参数：initState<br>返回值：{ current: initState }</p><p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initState）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>ref用来访问DOM，useRef同样也可以，但是useRef能做更多可变值的保存。用useRef申明的值和一个普通的js对象的区别在于useRef每次都返回同一个ref对象，而不会重新创建。</p><p>主要应用场景：</p><ul><li><p>组件内部一次渲染需要用到另一个state值，但此时state值永远都是初始值，useRef可以用来记录每一次更新后的state，方便在其他渲染逻辑中能访问到最新值</p></li><li><p>记录组件中的某一个元素</p></li><li><p>父组件调用子组件的方法，通常配合forwardRef + useImperativeHandle来使用，使用FancyInput的组件中绑定ref就可以访问到focus方法， <code>&lt;FancyInput ref={inputRef} /&gt;</code>父组件中调用 <code>inputRef.current.focus()</code></p></li></ul><p>示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function FancyInput(props, ref) &#123;</span><br><span class="line">  const inputRef &#x3D; useRef();</span><br><span class="line">  useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">    focus: () &#x3D;&gt; &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  return &lt;input ref&#x3D;&#123;inputRef&#125; ... &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput &#x3D; forwardRef(FancyInput);</span><br></pre></td></tr></table></figure><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p><code>const MyContext = React.createContext()</code></p><p>参数：context对象（MyContext）<br>返回值：传入context对象的值</p><p>context可以在跨多个层级组件之间通讯，当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p><p>调用了 useContext 的组件总会在 context 值变化时重新渲染，即使使用了React.memo。</p><p>子孙组件通过调用 useContext(MyContext) 可以拿到上层组件中的 context 的 value</p><h4 id="useReducer-useContext-综合运用案例"><a href="#useReducer-useContext-综合运用案例" class="headerlink" title="useReducer + useContext 综合运用案例"></a>useReducer + useContext 综合运用案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 祖组件 --&gt;</span><br><span class="line"></span><br><span class="line">const TodosDispatch &#x3D; React.createContext(null);</span><br><span class="line">function todosReducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case: &#39;&#39;:</span><br><span class="line">      &#x2F;&#x2F; do something</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function TodosApp() &#123;</span><br><span class="line">  &#x2F;&#x2F; 提示：&#96;dispatch&#96; 不会在重新渲染之间变化</span><br><span class="line">  const [todos, dispatch] &#x3D; useReducer(todosReducer);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;TodosDispatch.Provider value&#x3D;&#123;dispatch&#125;&gt;</span><br><span class="line">      &lt;DeepTree todos&#x3D;&#123;todos&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;TodosDispatch.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子孙组件 --&gt;</span><br><span class="line">function DeepChild(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span><br><span class="line">  const dispatch &#x3D; useContext(TodosDispatch);</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    dispatch(&#123; type: &#39;add&#39;, text: &#39;hello&#39; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Add todo&lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><p>我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。<br>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;react-hooks&quot;],</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;react-hooks&#x2F;rules-of-hooks&quot;: &#39;error&#39;,&#x2F;&#x2F; 检查 Hook 的规则</span><br><span class="line">    &quot;react-hooks&#x2F;exhaustive-deps&quot;: &#39;warn&#39; &#x2F;&#x2F; 检查 effect 的依赖</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考链接<br>1.官方文档：<a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener">https://react.docschina.org/docs/hooks-reference.html</a><br>2.掘金链接地址：</p></blockquote><ul><li><a href="https://juejin.im/post/5de38c76e51d455f9b335eff" target="_blank" rel="noopener">https://juejin.im/post/5de38c76e51d455f9b335eff</a></li><li><a href="https://juejin.im/post/5c9827745188250ff85afe50" target="_blank" rel="noopener">https://juejin.im/post/5c9827745188250ff85afe50</a></li><li><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d" target="_blank" rel="noopener">https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hook规则&quot;&gt;&lt;a href=&quot;#hook规则&quot; clas
      
    
    </summary>
    
      <category term="FE" scheme="https://fox-z.github.io/categories/FE/"/>
    
    
      <category term="React" scheme="https://fox-z.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>小程序输入框问题解决方案(Taro)</title>
    <link href="https://fox-z.github.io/2020/05/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://fox-z.github.io/2020/05/20/微信小程序输入框问题解决方案/</id>
    <published>2020-05-20T06:16:54.000Z</published>
    <updated>2020-09-10T11:56:06.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Taro小程序最近做的比较多的，业务涉及到都是表单相关组件，吃了不少苦头，于是就有了这篇文章，记录下经验，也希望能帮到你。</p></blockquote><p><strong>本文的所有场景都是基于页面中有大量input,textarea等文本输入组件</strong></p><h2 id="你不知道的input"><a href="#你不知道的input" class="headerlink" title="你不知道的input"></a>你不知道的input</h2><ul><li>input在聚焦focus时表现为原生组件，层级最高，脱离page限制，设置z-index都无法改变</li><li>input默认有z-index: [1-2) 的层级，这个很多人都踩过坑<blockquote><p>举个例子：某一个页面有大量输入框，底部有个悬浮的按钮btn, 固定定位的。当滑动页面 使btn覆盖在input上时，点击btn会发现注册在btn上的事件失效，点了没反应… ，如果这时脑子里想到的全是原生组件层级最高，那么你就进坑了，（没错，说的就是我）,然后就走向cover-view实现btn这条不归路，cover-view会定位错乱，滑动之后btn就飞了。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 贴点代码 方便理解（错误示例）</span><br><span class="line"></span><br><span class="line">&lt;Input</span><br><span class="line">  className&#x3D;&quot;ipt&quot;</span><br><span class="line">  type&#x3D;&quot;number&quot;</span><br><span class="line">  placeholderClass&#x3D;&quot;ipt-place&quot;</span><br><span class="line">  value&#x3D;&#123;phone&#125;</span><br><span class="line">  onInput&#x3D;&#123;this.phoneChange&#125;</span><br><span class="line">  placeholder&#x3D;&quot;请输入手机号&quot;</span><br><span class="line">&gt;&lt;&#x2F;Input&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按钮</span><br><span class="line">&lt;View className&#x3D;&quot;btn-wrap&quot;&gt;</span><br><span class="line">  &lt;CoverView</span><br><span class="line">    className&#x3D;&quot;btn&quot;</span><br><span class="line">    onClick&#x3D;&#123;this.confirm&#125;</span><br><span class="line">  &gt;保存&lt;&#x2F;CoverView&gt;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; css</span><br><span class="line"></span><br><span class="line">.btn-wrap&#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  z-index: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然解决思路错了，实际上结合上面第一条和第二条就知道错在哪里了，input没有聚焦的时候不是原生组件。我思路错的原因在于我开始的时候btn-wrap的z-index设置为1了，<strong>以为比页面元素高</strong>，于是当按钮覆盖input的时候，input的层级在btn之上, 这就是奇怪的地方，同样是1，后设置zIndex的元素应该在上面，但是这个例子中在开发工具和真机上都表现出input在上面的情况。当我把btn-wrap的zIndex设置为2的时候表现正常了，按钮在上，点击也正常了。所以我得出结论，input有1-2的层级。底部按钮不需要使用cover-view,用普通的view即可。</p><ul><li>input类型为number在一些真机上会出现 聚焦时页面白屏，输入时闪烁的问题，替代方案是用digit,text, 之后结果自己处理下（正则限制）</li></ul><h2 id="TextArea的一些骚操作"><a href="#TextArea的一些骚操作" class="headerlink" title="TextArea的一些骚操作"></a>TextArea的一些骚操作</h2><ul><li><p>原生组件，没有同层渲染，层级最高，页面中如果有弹窗就要注意了，textarea会覆盖在弹窗之上，不管你的弹窗层级多高。鉴于这种情况，弹窗，自定义头部等一切高于页面本身元素的组件建议用cover-view和cover-img搭配实现。</p></li><li><p>TextArea当作按钮，没错，你没听错</p><p>说说为啥用TextArea做按钮，当一个全是Textarea输入框的时候，底部有悬浮按钮，按钮上绑定了事件handle，想象一下。这时候底部按钮就不能用普通的View了，层级原因，鉴于cover-view定位有问题的情况，我尝试了canvas，input，textarea，最后选择了textarea(disable)这种做按钮，并设置了zIndex，canvas 高版本sdk中为同层渲染，input也是。只能textarea了，以彼之道还施彼身。这样就覆盖在页面中的textarea之上了。</p></li></ul><p><strong>以为textarea(disable)加个样式就实现了？？？</strong></p><p>  上真机上一看，ios上按钮正常显示，点击按钮handle事件也执行了，别激动<br>  安卓上看看，按钮正常显示，点击，没反应。。。原因是disable导致的，于是乎我又开始拿出我的钻地弹了，各种尝试，终于发现textarea设置了padding有效，就是点击padding的区域，事件handle能执行，于是乎我设置padding充满了整个textarea，让按钮每一个角落都能点击。<br>  现在才说实现了 ui + 点击。（测试了部分机型，可以的，如果有其他机型不行，告诉我。当然如果原生textarea实现有变动，可能就用不了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Textarea</span><br><span class="line">  disabled</span><br><span class="line">  fixed</span><br><span class="line">  disableDefaultPadding</span><br><span class="line">&gt;&lt;&#x2F;Textarea&gt;</span><br><span class="line"></span><br><span class="line">textarea&#123;</span><br><span class="line">  height: 40px;</span><br><span class="line">  padding: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cover-view-amp-amp-cover-img组件使用注意事项"><a href="#cover-view-amp-amp-cover-img组件使用注意事项" class="headerlink" title="cover-view &amp;&amp; cover-img组件使用注意事项"></a>cover-view &amp;&amp; cover-img组件使用注意事项</h2><blockquote><p>以下统称cover组件</p></blockquote><ul><li><p>cover组件表现层级最高，cover-view 在小程序中是比较特殊的组件，与 view 的最大区别在于，它能覆盖在原生组件 map、video、canvas、camera 之上，且只能嵌套 cover-view， button 和 cover-image。如果说textarea是顶楼，那么cover就是天台，没有比cover组件层级更高的组件了。</p></li><li><p>cover-view 单边border设置无效<br>真机上表现为全border，所以需要处理，思路有两种</p><ul><li>再写一个cover-view高度为1，背景色设置为边框色</li><li>让ui切个边框图，写一个cover-img实现</li></ul></li><li><p>cover-view在fixed的盒子中，无法正常定位，会随页面的滚动而滚动</p></li></ul><blockquote><p>同样是底部按钮悬浮的场景</p></blockquote><p>这种情况是基础库低于1.9.90版本出现的，由于最外层 cover-view 不支持 position: fixed; 所以最外层盒子采用 view 定位 position: fixed;<br>基础库 1.9.90 起最外层 cover-view 支持 position: fixed, 但是在部分机型上仍然会出现 键盘弹起，滑动页面 场景下 定位错乱的问题，目前还未解决，但是有替代方案textarea。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Taro小程序最近做的比较多的，业务涉及到都是表单相关组件，吃了不少苦头，于是就有了这篇文章，记录下经验，也希望能帮到你。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文的所有场景都是基于页面中有大量input,textarea等文
      
    
    </summary>
    
      <category term="FE" scheme="https://fox-z.github.io/categories/FE/"/>
    
    
      <category term="miniprogram" scheme="https://fox-z.github.io/tags/miniprogram/"/>
    
  </entry>
  
  <entry>
    <title>Hexo基本命令</title>
    <link href="https://fox-z.github.io/2019/09/10/Hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://fox-z.github.io/2019/09/10/Hexo基本命令/</id>
    <published>2019-09-10T02:41:37.000Z</published>
    <updated>2020-09-10T11:57:04.182Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="tools" scheme="https://fox-z.github.io/categories/tools/"/>
    
    
      <category term="Hexo" scheme="https://fox-z.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
