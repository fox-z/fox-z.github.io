{"meta":{"title":"依禅 - 个人博客","subtitle":"","description":"依禅的个人博客系统，主要分享技术文章或者生活类的文章","author":"yichan","url":"https://fox-z.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-03-22T13:49:20.000Z","updated":"2020-03-22T13:49:20.030Z","comments":true,"path":"tags/index.html","permalink":"https://fox-z.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-30T07:12:39.795Z","updated":"2020-05-30T07:12:39.795Z","comments":true,"path":"categories/FE/index.html","permalink":"https://fox-z.github.io/categories/FE/index.html","excerpt":"","text":"前端专栏"},{"title":"","date":"2020-05-20T13:04:10.848Z","updated":"2020-05-20T13:04:10.848Z","comments":true,"path":"categories/life/index.html","permalink":"https://fox-z.github.io/categories/life/index.html","excerpt":"","text":"生活专栏"},{"title":"","date":"2020-05-20T13:04:17.467Z","updated":"2020-05-20T13:04:17.467Z","comments":true,"path":"categories/tools/index.html","permalink":"https://fox-z.github.io/categories/tools/index.html","excerpt":"","text":"工具专栏"}],"posts":[{"title":"Hooks基本用法","slug":"Hooks","date":"2020-05-30T06:16:54.000Z","updated":"2020-05-30T07:12:04.283Z","comments":true,"path":"2020/05/30/Hooks/","link":"","permalink":"https://fox-z.github.io/2020/05/30/Hooks/","excerpt":"","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 hook规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。简单的讲：react依赖hook定义的顺序，以便在每一次重渲染时都能准确更新状态. 只在 React 函数中调用 Hook 在 React 的函数组件中调用 Hook在自定义 Hook 中调用其他 Hook useStateuseState主要用来定义可以影响视图的变量 参数：initState 两种类型(any || () =&gt; {})返回值：[a, setA] (数组且只有两个参数) 思考下为啥是一个数组？ 如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。 如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用： 示例： 123456789101112import &#123; useState &#125; from &#39;react&#39;function App() &#123; const [a, setA] &#x3D; useState(0); &#x2F;&#x2F; const [a, setA] &#x3D; useState(() &#x3D;&gt; 0); return ( &lt;&gt; &lt;div&gt;&#123;a&#125;&lt;&#x2F;div&gt; &lt;&#x2F;&gt; )&#125; 主要使用场景：定义组件内部的一些状态 useReducer参数：（reducerFunction, initState）返回值：[a, dispatchA] (数组且只有两个参数) useReducer和useState一样主要用来定义可以影响视图的变量useState底层用的还是useReducer，所以你任何时候可以使用useReducer代替useState 12345const [items, dispatch] &#x3D; useReducer((state, action) &#x3D;&gt; &#123; switch (action.type) &#123; &#x2F;&#x2F; do something with the action &#125;&#125;, []); 主要使用场景：在useState的基础上，useReducer多了在父子组件通讯上的功能，比如可以直接向子组件传递一个dispatch 而不是 回调函数，另外在处理复杂逻辑时显然useReducer显得更加优雅。 注意点 对于引用类型的数据，例如数组。useState和useReducer都是不可以直接对变量（a）进行操作的，必须切断引用关系，新值才会生效 解决方案：对于复杂数据类型 通用的方案是 immer use-immer, 使用useImmer替代useState 是更加合理的方案 qa: 当组件拥有多个 state 时，应该把多个 state 合并成一个 state ，还是把 state 切分成多个 state 变量？ 要么把所有 state 都放在同一个 useState 调用中，要么每一个字段都对应一个 useState 调用，这两方式都能跑通。 当你在这两个极端之间找到平衡，然后把相关 state 组合到几个独立的 state 变量时，组件就会更加的可读。如果 state 的逻辑开始变得复杂，我们推荐用 useReducer 来管理它，或使用自定义 Hook。 useEffect参数：(callback, []?)返回值：可选 (componentWillUnmount) useEffect 用来取代 componentDidMount , componentDidUpdate 和 componentWillUnmount。主要作用是当页面渲染后，进行一些副作用操作 副作用：访问 DOM，请求数据，定时器，订阅消息。 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。 每次 Render 都有自己的 Props 与 State可以认为每次 Render 的内容都会形成一个快照并保留下来，因此当状态变更而 Rerender 时，就形成了 N 个 Render 状态，而每个 Render 状态都拥有自己固定不变的 Props 与 State。 在每次点击时，count 只是一个不会变的常量，而且也不存在利用 Proxy 的双向绑定，只是一个常量存在于每次 Render 中。初始状态下 count 值为 0，而随着按钮被点击，在每次 Render 过程中，count 的值都会被固化为 1、2、3： 1234567891011121314151617181920212223&#x2F;&#x2F; During first renderfunction Counter() &#123; const count &#x3D; 0; &#x2F;&#x2F; Returned by useState() &#x2F;&#x2F; ... &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; After a click, our function is called againfunction Counter() &#123; const count &#x3D; 1; &#x2F;&#x2F; Returned by useState() &#x2F;&#x2F; ... &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; After another click, our function is called againfunction Counter() &#123; const count &#x3D; 2; &#x2F;&#x2F; Returned by useState() &#x2F;&#x2F; ... &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;; &#x2F;&#x2F; ...&#125; 几个用法 useEffect当作componentDidMount用 123456789useEffect(() &#x3D;&gt; &#123; const fetchData &#x3D; async () &#x3D;&gt; &#123; const result &#x3D; await axios( &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;, ); setData(result.data); &#125;; fetchData();&#125;, []); useEffect当作componentDidMount, componentDidUpdate用 123456789useEffect(() &#x3D;&gt; &#123; const fetchData &#x3D; async () &#x3D;&gt; &#123; const result &#x3D; await axios( &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;, ); setData(result.data); &#125;; fetchData();&#125;, [page]); useEffect当作componentDidMount, componentDidUpdate,componentWillUnmount用 12345678910111213useEffect(() &#x3D;&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); &#x2F;&#x2F; Specify how to clean up after this effect: return function cleanup() &#123; &#x2F;&#x2F; 清除订阅 ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, []);&#x2F;&#x2F; 清除订阅在每次渲染都会执行，以确保老的视图不会对新视图造成副作用 性能优化建议： 依赖项数组控制着 useEffect 的执行 如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 useEffect 不能接收 async 作为回调函数，useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise 在 useEffect 中调用用函数时，要把该函数在 useEffect 中申明，不能放到外部申明，然后再在 useEffect 中调用，你会想要在 effect 内部 去声明它所需要的函数。 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值 useLayoutEffect useLayoutEffect与useEffect作用比较相同 区别点在于执行的时机 useEffect在全部渲染完毕后才会执行，useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行 可以使用它来读取 DOM 布局并同步触发重渲染 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect 在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被同步刷新 尽可能使用标准的 useEffect 以避免阻塞视图更新 1234567891011121314151617function LayoutEffect() &#123; const [color, setColor] &#x3D; useState(&#39;red&#39;); useLayoutEffect(() &#x3D;&gt; &#123; alert(color); &#x2F;&#x2F; 阻塞了渲染 &#125;); useEffect(() &#x3D;&gt; &#123; console.log(&#39;color&#39;, color); &#125;); return ( &lt;&gt; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&#123;&#123; background: color &#125;&#125;&gt;颜色&lt;&#x2F;div&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;red&#39;)&#125;&gt;红&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;yellow&#39;)&#125;&gt;黄&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;blue&#39;)&#125;&gt;蓝&lt;&#x2F;button&gt; &lt;&#x2F;&gt; );&#125; useCallback参数：(callback, []?)返回值: function 接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新 第二个参数为依赖项，如果没有则每次都会执行返回值函数，为空数组，组件初始化的时候执行一次，后续 update 则取缓存里的，数组有依赖项，则在依赖项变更时触发useCallback。所以为了更好的性能，务必指定第二个参数 主要应用场景：父组件给子组件绑定方法，若非使用useCallback，则子组件在每次父组件render的时候都会重新渲染，推荐子组件搭配 React.memo 高阶函数一起使用。 useMemo参数：(callback, []?)返回值: any 把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的 主要应用场景：熟悉Vue的同学可以把这个当作computed计算属性来理解，因此callback中最好指定return 项 useCallback 与 useMemo 的异同点 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps), 最终的返回值都是一个 test 的memoized版本 useMemo更适合计算属性的场景，昂贵的计算 （购物车计算价格数量等） useCallback更适合给组件绑定方法 useCallback返回的只能是函数，useMemo能返回多种类型 useRef参数：initState返回值：{ current: initState } useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initState）。返回的 ref 对象在组件的整个生命周期内保持不变。 ref用来访问DOM，useRef同样也可以，但是useRef能做更多可变值的保存。用useRef申明的值和一个普通的js对象的区别在于useRef每次都返回同一个ref对象，而不会重新创建。 主要应用场景： 组件内部一次渲染需要用到另一个state值，但此时state值永远都是初始值，useRef可以用来记录每一次更新后的state，方便在其他渲染逻辑中能访问到最新值 记录组件中的某一个元素 父组件调用子组件的方法，通常配合forwardRef + useImperativeHandle来使用，使用FancyInput的组件中绑定ref就可以访问到focus方法， &lt;FancyInput ref={inputRef} /&gt;父组件中调用 inputRef.current.focus() 示例如下 12345678910function FancyInput(props, ref) &#123; const inputRef &#x3D; useRef(); useImperativeHandle(ref, () &#x3D;&gt; (&#123; focus: () &#x3D;&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref&#x3D;&#123;inputRef&#125; ... &#x2F;&gt;;&#125;FancyInput &#x3D; forwardRef(FancyInput); useContextconst MyContext = React.createContext() 参数：context对象（MyContext）返回值：传入context对象的值 context可以在跨多个层级组件之间通讯，当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 调用了 useContext 的组件总会在 context 值变化时重新渲染，即使使用了React.memo。 子孙组件通过调用 useContext(MyContext) 可以拿到上层组件中的 context 的 value useReducer + useContext 综合运用案例12345678910111213141516171819202122232425262728293031323334&lt;!-- 祖组件 --&gt;const TodosDispatch &#x3D; React.createContext(null);function todosReducer(state, action) &#123; switch (action.type) &#123; case: &#39;&#39;: &#x2F;&#x2F; do something break; &#125;&#125;function TodosApp() &#123; &#x2F;&#x2F; 提示：&#96;dispatch&#96; 不会在重新渲染之间变化 const [todos, dispatch] &#x3D; useReducer(todosReducer); return ( &lt;TodosDispatch.Provider value&#x3D;&#123;dispatch&#125;&gt; &lt;DeepTree todos&#x3D;&#123;todos&#125; &#x2F;&gt; &lt;&#x2F;TodosDispatch.Provider&gt; );&#125;&lt;!-- 子孙组件 --&gt;function DeepChild(props) &#123; &#x2F;&#x2F; 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。 const dispatch &#x3D; useContext(TodosDispatch); function handleClick() &#123; dispatch(&#123; type: &#39;add&#39;, text: &#39;hello&#39; &#125;); &#125; return ( &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Add todo&lt;&#x2F;button&gt; );&#125; 语法检查我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。示例如下： 12345678&#123; &quot;plugins&quot;: [&quot;react-hooks&quot;], &#x2F;&#x2F; ... &quot;rules&quot;: &#123; &quot;react-hooks&#x2F;rules-of-hooks&quot;: &#39;error&#39;,&#x2F;&#x2F; 检查 Hook 的规则 &quot;react-hooks&#x2F;exhaustive-deps&quot;: &#39;warn&#39; &#x2F;&#x2F; 检查 effect 的依赖 &#125;&#125; 本文参考链接1.官方文档：https://react.docschina.org/docs/hooks-reference.html2.掘金链接地址： https://juejin.im/post/5de38c76e51d455f9b335eff https://juejin.im/post/5c9827745188250ff85afe50 https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://fox-z.github.io/tags/React/"}]},{"title":"小程序输入框问题解决方案(Taro)","slug":"微信小程序输入框问题解决方案","date":"2020-05-20T06:16:54.000Z","updated":"2020-05-20T11:21:45.291Z","comments":true,"path":"2020/05/20/微信小程序输入框问题解决方案/","link":"","permalink":"https://fox-z.github.io/2020/05/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"Taro小程序最近做的比较多的，业务涉及到都是表单相关组件，吃了不少苦头，于是就有了这篇文章，记录下经验，也希望能帮到你。 本文的所有场景都是基于页面中有大量input,textarea等文本输入组件 你不知道的input input在聚焦focus时表现为原生组件，层级最高，脱离page限制，设置z-index都无法改变 input默认有z-index: [1-2) 的层级，这个很多人都踩过坑 举个例子：某一个页面有大量输入框，底部有个悬浮的按钮btn, 固定定位的。当滑动页面 使btn覆盖在input上时，点击btn会发现注册在btn上的事件失效，点了没反应… ，如果这时脑子里想到的全是原生组件层级最高，那么你就进坑了，（没错，说的就是我）,然后就走向cover-view实现btn这条不归路，cover-view会定位错乱，滑动之后btn就飞了。 123456789101112131415161718192021222324252627&#x2F;&#x2F; 贴点代码 方便理解（错误示例）&lt;Input className&#x3D;&quot;ipt&quot; type&#x3D;&quot;number&quot; placeholderClass&#x3D;&quot;ipt-place&quot; value&#x3D;&#123;phone&#125; onInput&#x3D;&#123;this.phoneChange&#125; placeholder&#x3D;&quot;请输入手机号&quot;&gt;&lt;&#x2F;Input&gt;&#x2F;&#x2F; 按钮&lt;View className&#x3D;&quot;btn-wrap&quot;&gt; &lt;CoverView className&#x3D;&quot;btn&quot; onClick&#x3D;&#123;this.confirm&#125; &gt;保存&lt;&#x2F;CoverView&gt;&lt;&#x2F;View&gt;&#x2F;&#x2F; css.btn-wrap&#123; position: fixed; bottom: 0; left: 0; z-index: 1&#125; 显然解决思路错了，实际上结合上面第一条和第二条就知道错在哪里了，input没有聚焦的时候不是原生组件。我思路错的原因在于我开始的时候btn-wrap的z-index设置为1了，以为比页面元素高，于是当按钮覆盖input的时候，input的层级在btn之上, 这就是奇怪的地方，同样是1，后设置zIndex的元素应该在上面，但是这个例子中在开发工具和真机上都表现出input在上面的情况。当我把btn-wrap的zIndex设置为2的时候表现正常了，按钮在上，点击也正常了。所以我得出结论，input有1-2的层级。底部按钮不需要使用cover-view,用普通的view即可。 input类型为number在一些真机上会出现 聚焦时页面白屏，输入时闪烁的问题，替代方案是用digit,text, 之后结果自己处理下（正则限制） TextArea的一些骚操作 原生组件，没有同层渲染，层级最高，页面中如果有弹窗就要注意了，textarea会覆盖在弹窗之上，不管你的弹窗层级多高。鉴于这种情况，弹窗，自定义头部等一切高于页面本身元素的组件建议用cover-view和cover-img搭配实现。 TextArea当作按钮，没错，你没听错 说说为啥用TextArea做按钮，当一个全是Textarea输入框的时候，底部有悬浮按钮，按钮上绑定了事件handle，想象一下。这时候底部按钮就不能用普通的View了，层级原因，鉴于cover-view定位有问题的情况，我尝试了canvas，input，textarea，最后选择了textarea(disable)这种做按钮，并设置了zIndex，canvas 高版本sdk中为同层渲染，input也是。只能textarea了，以彼之道还施彼身。这样就覆盖在页面中的textarea之上了。 以为textarea(disable)加个样式就实现了？？？ 上真机上一看，ios上按钮正常显示，点击按钮handle事件也执行了，别激动 安卓上看看，按钮正常显示，点击，没反应。。。原因是disable导致的，于是乎我又开始拿出我的钻地弹了，各种尝试，终于发现textarea设置了padding有效，就是点击padding的区域，事件handle能执行，于是乎我设置padding充满了整个textarea，让按钮每一个角落都能点击。 现在才说实现了 ui + 点击。（测试了部分机型，可以的，如果有其他机型不行，告诉我。当然如果原生textarea实现有变动，可能就用不了） 12345678910&lt;Textarea disabled fixed disableDefaultPadding&gt;&lt;&#x2F;Textarea&gt;textarea&#123; height: 40px; padding: 20px;&#125; cover-view &amp;&amp; cover-img组件使用注意事项 以下统称cover组件 cover组件表现层级最高，cover-view 在小程序中是比较特殊的组件，与 view 的最大区别在于，它能覆盖在原生组件 map、video、canvas、camera 之上，且只能嵌套 cover-view， button 和 cover-image。如果说textarea是顶楼，那么cover就是天台，没有比cover组件层级更高的组件了。 cover-view 单边border设置无效真机上表现为全border，所以需要处理，思路有两种 再写一个cover-view高度为1，背景色设置为边框色 让ui切个边框图，写一个cover-img实现 cover-view在fixed的盒子中，无法正常定位，会随页面的滚动而滚动 同样是底部按钮悬浮的场景 这种情况是基础库低于1.9.90版本出现的，由于最外层 cover-view 不支持 position: fixed; 所以最外层盒子采用 view 定位 position: fixed;基础库 1.9.90 起最外层 cover-view 支持 position: fixed, 但是在部分机型上仍然会出现 键盘弹起，滑动页面 场景下 定位错乱的问题，目前还未解决，但是有替代方案textarea。","categories":[],"tags":[{"name":"miniprogram","slug":"miniprogram","permalink":"https://fox-z.github.io/tags/miniprogram/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-22T12:46:32.229Z","updated":"2020-03-22T13:24:38.830Z","comments":true,"path":"2020/03/22/hello-world/","link":"","permalink":"https://fox-z.github.io/2020/03/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}