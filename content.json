{"meta":{"title":"依禅 - 个人博客","subtitle":"","description":"依禅的个人博客系统，主要分享技术文章或者生活类的文章","author":"yichan","url":"https://fox-z.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-03-22T13:49:20.000Z","updated":"2020-03-22T13:49:20.030Z","comments":true,"path":"tags/index.html","permalink":"https://fox-z.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-30T07:12:39.795Z","updated":"2020-05-30T07:12:39.795Z","comments":true,"path":"categories/FE/index.html","permalink":"https://fox-z.github.io/categories/FE/index.html","excerpt":"","text":"前端专栏"},{"title":"","date":"2020-05-20T13:04:10.848Z","updated":"2020-05-20T13:04:10.848Z","comments":true,"path":"categories/life/index.html","permalink":"https://fox-z.github.io/categories/life/index.html","excerpt":"","text":"生活专栏"},{"title":"","date":"2020-05-20T13:04:17.467Z","updated":"2020-05-20T13:04:17.467Z","comments":true,"path":"categories/tools/index.html","permalink":"https://fox-z.github.io/categories/tools/index.html","excerpt":"","text":"工具专栏"}],"posts":[{"title":"puppeteer实践","slug":"puppeteer实践","date":"2020-09-10T02:41:37.000Z","updated":"2020-09-21T08:26:41.175Z","comments":true,"path":"2020/09/10/puppeteer实践/","link":"","permalink":"https://fox-z.github.io/2020/09/10/puppeteer%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"puppeteer简单介绍英 [ˌpʌpɪˈtɪə(r)] Puppeteer 是 Node.js 工具引擎 Puppeteer 提供了一系列 API，通过 Chrome DevTools Protocol 协议控制 Chromium/Chrome 浏览器的行为 Puppeteer 默认情况下是以 headless 启动 Chrome 的，也可以通过参数控制启动有界面的 Chrome Puppeteer 默认绑定最新的 Chromium 版本，也可以自己设置不同版本的绑定 Puppeteer 让我们不需要了解太多的底层 CDP 协议实现与浏览器的通信 Puppeteer API 是分层次的，反映了浏览器结构。 Browser 实例可以拥有浏览器上下文。 BrowserContext 实例定义了一个浏览会话并可拥有多个页面。 Page 至少有一个框架：主框架。 可能还有其他框架由 iframe 或 框架标签 创建。 frame 至少有一个执行上下文 – 默认的执行上下文 – 框架的 JavaScript 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。 Worker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。 中文官网地址: https://www.mofazhuan.com/puppeteer-doc-zh#puppeteerlaunchoptionsgithub: https://github.com/puppeteer/puppeteer puppeteer的能力 网页截图或者生成 PDF 爬取网站（SPA 或 SSR） UI 自动化测试，模拟表单提交，键盘输入，点击等行为 捕获网站的时间线，帮助诊断性能问题 创建一个最新的自动化测试环境，使用最新的 js 和最新的 Chrome 浏览器运行测试用例 测试 Chrome 扩展程序 安装puppeteer其实puppeteer是 Chromium+API 的合体，下载的时候需要注意 Chromium 是否正常安装，如若不行则手动下载。服务器上尝试多次都无法正常下载，所以最好手动下载好服务器支持的版本，直接复制过去。 下载地址：https://npm.taobao.org/mirrors/chromium-browser-snapshots/ 不同的系统安装不同的chrome，推荐安装版本：782078 创建一个浏览器实例12345678910111213141516171819202122232425262728293031import puppeteer from &#39;puppeteer&#39;;(async () &#x3D;&gt; &#123; const browser &#x3D; await puppeteer.launch(&#123; &#x2F;&#x2F; 无头模式 指不打开浏览器窗口 headless: true, &#x2F;&#x2F; 是否以 无头模式 运行浏览器 false 打开浏览器，设置 true 不打开 无头浏览器 args: [ &#39;--no-sandbox&#39;, &#x2F;&#x2F; 如果没有可用于Chrome的优质沙箱，它将因错误崩溃，如果您完全信任在Chrome中打开的内容，则可以使用以下--no-sandbox参数启动Chrome &#39;–single-process&#39;, &#x2F;&#x2F; Dom解析和渲染放到同一进程 &#39;–disable-gpu&#39;, &#x2F;&#x2F; disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算 &#39;–disable-dev-shm-usage&#39;, &#x2F;&#x2F; 禁止使用 &#x2F;dev&#x2F;shm 共享内存 (Chrome 默认使用 &#x2F;dev&#x2F;shm 共享内存docker 默认&#x2F;dev&#x2F;shm 只有64MB) &#39;–disable-setuid-sandbox&#39;, &#x2F;&#x2F; Disable the setuid sandbox (Linux only). ↪ &#39;–no-first-run&#39;, &#x2F;&#x2F; 跳过第一次运行任务 &#39;–no-zygote&#39;, &#x2F;&#x2F; 禁止使用合子进程来分叉子进程 ], ignoreDefaultArgs: [ &#39;--disable-extensions&#39; ], &#x2F;&#x2F; 扩展程序 defaultViewport: &#123; width: 800, &#x2F;&#x2F; 页面宽度像素。建议不超过1000px，会有崩溃的情况 height: 800, &#x2F;&#x2F; &lt;number&gt; 页面高度像素。 &#125;, &#125;); &#x2F;&#x2F; 打开一个了浏览器tab const page &#x3D; await browser.newPage(); &#x2F;&#x2F; 在tab中打开百度官网 await page.goto(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;); &#x2F;&#x2F; 关闭tab await page.close(); &#x2F;&#x2F; 关闭浏览器 await browser.close();&#125;)(); 做个简单的应用实战示例，激起你们的兴趣 抓取阮一峰es6这本电子书，生成pdf文档 代码展示如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&#x2F;&#x2F; 以下为egg代码 &#39;use strict&#39;;const Controller &#x3D; require(&#39;egg&#39;).Controller;const Response &#x3D; require(&#39;..&#x2F;..&#x2F;extend&#x2F;response&#39;);const path &#x3D; require(&#39;path&#39;);const fs &#x3D; require(&#39;fs&#39;);&#x2F;&#x2F; pdf页脚const footerTemplate &#x3D; &#96;&lt;div style&#x3D;&quot;width:80%;margin:0 auto;font-size: 8px;padding:10px 0;display: flex; justify-content: space-between; &quot;&gt; &lt;span style&#x3D;&quot;&quot;&gt;页码&lt;&#x2F;span&gt; &lt;div&gt;&lt;span class&#x3D;&quot;pageNumber&quot;&gt; &lt;&#x2F;span&gt; &#x2F; &lt;span class&#x3D;&quot;totalPages&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;;&#x2F;&#x2F; pdf页眉const headerTemplate &#x3D; &#96;&lt;div style&#x3D;&quot;width:80%;margin:0 auto;font-size: 8px;padding:10px 0;display: flex; justify-content: space-between;&quot;&gt; &lt;&#x2F;div&gt;&#96;;const defaultOptions &#x3D; &#123; displayHeaderFooter: false, &#x2F;&#x2F; headerTemplate, &#x2F;&#x2F; footerTemplate, format: &#39;A4&#39;, margin: &#123; top: &#39;20px&#39;, bottom: &#39;20px&#39;, &#125;,&#125;;class ExampleController extends Controller &#123; sleep(time) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; try &#123; setTimeout(() &#x3D;&gt; &#123; resolve(1); &#125;, time); &#125; catch (e) &#123; reject(0) &#125; &#125;) &#125; async index() &#123; const &#123; ctx, app, config &#125; &#x3D; this; const &#123; baseDir, localImgDir&#125; &#x3D; config; try &#123; &#x2F;&#x2F; 生成单号对应的文件，便于操作pdf文件 const es6FileName &#x3D; path.join(baseDir, localImgDir, &#39;es6&#39;); if (!fs.existsSync(es6FileName)) &#123; fs.mkdirSync(es6FileName); &#125; ctx.runInBackground(async () &#x3D;&gt; &#123; await app.pagePool.use(async page &#x3D;&gt; &#123; &#x2F;&#x2F; 前往es6网站 await page.goto(&#39;https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;&#39;, &#123; waitUntil: &#39;load&#39;, &#125;); await this.sleep(2000); let linkTags &#x3D; await page.evaluate(() &#x3D;&gt; &#123; let aArrs &#x3D; [...document.querySelectorAll(&#39;#sidebar ol li a&#39;)]; return aArrs.map((aTag) &#x3D;&gt; &#123; return &#123; href: aTag.href, name: aTag.text &#125; &#125;); &#125;); ctx.logger.info(&#39;打印目录linkTags&#39;, linkTags); for(let i &#x3D; 0, len &#x3D; linkTags.length; i &lt; len; i++) &#123; const pdfItem &#x3D; linkTags[i]; const pdfOutPath &#x3D; path.join(baseDir, localImgDir, &#39;es6&#39;, &#96;$&#123;i&#125;.$&#123;pdfItem.name&#125;.pdf&#96;); await page.goto(pdfItem.href, &#123; waitUntil: &#39;load&#39; &#125;); await this.sleep(4000); ctx.logger.info(&#39;打印中++++&#39;, pdfOutPath); await page.pdf(&#123; ...defaultOptions, path: pdfOutPath, &#125;); &#125; ctx.logger.info(&#39;生成成功++++&#39;); return; &#125;, ctx); &#125;); Response.SUCCESS(ctx, &#39;成功&#39;); &#125; catch (err) &#123; Response.SYSTEMERR(ctx, err); ctx.logger.error(&#39;es6-ExampleController-errow&#39;, err); &#125; &#125;&#125;module.exports &#x3D; ExampleController; 两个独立的环境在使用 Puppeteer 时我们几乎一定会遇到在这两个环境之间交换数据：运行 Puppeteer 的 Node.js 环境和 Puppeteer 操作的页面 Page DOM，理解这两个环境很重要 首先 Puppeteer 提供了很多有用的函数去 Page DOM Environment 中执行代码其次 Puppeteer 提供了 ElementHandle 和 JsHandle 将 Page DOM Environment 中元素和对象封装成对应的 Node.js 对象，这样可以直接这些对象的封装函数进行操作 Page DOM 在项目中的使用 启动配置 默认开启一个浏览器，10个tab页面，维护在一个池子里，每次用到的时候，去池子里拿到空闲的那个tab页，去执行业务。 q: 为啥不是用到的时候再打开一个浏览器，一个tab页，使用后就关闭？q: 为什么启动的时候打开这么多？q: 打开的这么多的页面会带来什么其他问题? 生成实时分享图片（截图功能） 上一段官网示例代码： 12345678const puppeteer &#x3D; require(&#39;puppeteer&#39;);puppeteer.launch().then(async browser &#x3D;&gt; &#123; const page &#x3D; await browser.newPage(); await page.goto(&#39;https:&#x2F;&#x2F;baidu.com&#39;); await page.screenshot(&#123;path: &#39;screenshot.png&#39;&#125;); await browser.close();&#125;); 注意：官网示例并不能直接生产使用，包括第三方代码(github)。 具体看项目代码，顺便review一下 导出发货单（生成pdf功能） 首先不管是本地开发，还是线上服务器都需要安装pdftk 服务器缺少pdftk应用，需要下载安装 yum install gcc gcc-c++ libXrandr gtk2 libXtst libart_lgpl wget http://mirror.centos.org/centos/6/os/x86_64/Packages/libgcj-4.4.7-23.el6.x86_64.rpm完成后执行：rpm -ivh –nodeps libgcj-4.4.7-23.el6.x86_64.rpm wget https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/pdftk-2.02-1.el6.x86_64.rpm完成后执行：yum install pdftk-2.02-1.el6.x86_64.rpm 测试是否安装成功,能正常打印路径即可which pdftk 本项目中只用到了pdftk中的合并pdf的功能，其他强大的功能并未使用到。 具体看项目代码，顺便review一下 服务器上遇到的坑 Chromium安装问题在服务器上需要先安装依赖项，以及chromecentOS: 依赖库yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y 字体yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y 安装完成后 更新nss libraryyum update nss -y 字体库支持问题推荐中日韩字体，一般服务器上字体不多，字体有乱码的情况，需要自己下载合适的字体 内存以及cpu资源的权衡批量生成图片或者pdf需要大量的文件操作，对cpu和内存都是考验，服务器上需要运维人员合理分配资源，本地开发多关注cpu和内存的损耗，有不合理的及时优化，避免上线后把服务器弄炸了。 性能优化 几个核心启动项 headless: true, // 是否以 无头模式 运行浏览器 false 打开浏览器，设置 true 不打开 无头浏览器 args: [ ‘–no-sandbox’, // 如果没有可用于Chrome的优质沙箱，它将因错误崩溃，如果您完全信任在Chrome中打开的内容，则可以使用以下–no-sandbox参数启动Chrome ‘–single-process’, // Dom解析和渲染放到同一进程 ‘–disable-gpu’, // disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算 ‘–disable-dev-shm-usage’, // 禁止使用 /dev/shm 共享内存 (Chrome 默认使用 /dev/shm 共享内存docker 默认/dev/shm 只有64MB) ‘–disable-setuid-sandbox’, // Disable the setuid sandbox (Linux only). ↪ ‘–no-first-run’, // 跳过第一次运行任务 ‘–no-zygote’, // 禁止使用合子进程来分叉子进程], ignoreDefaultArgs: [ ‘–disable-extensions’ ], // 扩展程序 说明： 推荐在本地或者服务器都开启无头模式，headless: true，原因有下：1.无头模式服务器才支持 2.无头模式才能生成pdf args启动项涉及到非常庞大的知识体系，其中的参数可大大节省启动时间，加快启动速度，以及避开一些服务器上的限制，具体可参考 https://peter.sh/experiments/chromium-command-line-switches/ ignoreDefaultArgs参数 配置 –disable-extensions 为禁用扩展程序，建议添加 连接池 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151const path &#x3D; require(&#39;path&#39;);const puppeteer &#x3D; require(&#39;puppeteer-core&#39;);&#x2F;&#x2F; const Response &#x3D; require(&#39;..&#x2F;app&#x2F;extend&#x2F;response&#39;);class Pool &#123; constructor(browserMax, pageMax, chromePath) &#123; this.browsers &#x3D; []; this.browserMax &#x3D; browserMax; this.pageMax &#x3D; pageMax; this.chromePath &#x3D; chromePath; this.useCount &#x3D; 100; &#125; async createAll() &#123; for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123; let browser &#x3D; await this.createBrowser(); this.browsers[i] &#x3D; &#123; browser, pages: []&#125;; let [defaultPage] &#x3D; await browser.pages(); &#x2F;&#x2F; defaultPage &#x3D; await this.setPage(defaultPage); this.browsers[i].pages[0] &#x3D; &#123; page: defaultPage, used: false, count: 0, browser &#125;; for (var k &#x3D; 1; k &lt; this.pageMax; k++) &#123; let page &#x3D; await this.createPage(browser); this.browsers[i].pages[k] &#x3D; &#123; page, used: false, count: 0, browser &#125;; &#125; &#125; return this.browsers; &#125; async createBrowser(w, h) &#123; let browser &#x3D; await puppeteer.launch(&#123; headless: true, ignoreHTTPSErrors: true, args: [ &#39;--no-sandbox&#39;, &#x2F;&#x2F; 如果没有可用于Chrome的优质沙箱，它将因错误崩溃，如果您完全信任在Chrome中打开的内容，则可以使用以下--no-sandbox参数启动Chrome &#39;–single-process&#39;, &#x2F;&#x2F; Dom解析和渲染放到同一进程 &#39;–disable-gpu&#39;, &#x2F;&#x2F; disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算 &#39;–disable-dev-shm-usage&#39;, &#39;–disable-setuid-sandbox&#39;, &#39;–no-first-run&#39;, &#39;–no-zygote&#39; ], ignoreDefaultArgs: [&#39;--disable-extensions&#39;], defaultViewport: &#123; width: w || 800, &#x2F;&#x2F; 页面宽度像素。不能超过1000px，会有崩溃的情况 height: h || 800, &#x2F;&#x2F; &lt;number&gt; 页面高度像素。 &#125;, executablePath: path.resolve(this.chromePath), &#125;); return browser; &#125; async createPage(browser) &#123; &#x2F;&#x2F; 使用默认的就是PC 的 devices &#x2F;&#x2F; const devices &#x3D; require(&quot;puppeteer&#x2F;DeviceDescriptors&quot;); &#x2F;&#x2F; const iPhonex &#x3D; devices[&quot;iPhone X&quot;]; let page &#x3D; await browser.newPage(); &#x2F;&#x2F; page &#x3D; await setPage(page); return page; &#125; async setPage(page) &#123; await page.setViewport(&#123; width: 800, height: 800 &#125;); await page.setRequestInterception(true); return page; &#125; async use(func, ctx) &#123; let item &#x3D; await this._findFreePage(); let ret; if (item) &#123; item.used &#x3D; true; item.count++; try &#123; ret &#x3D; await func(item.page); &#125; catch (e) &#123; ret &#x3D; false; &#125; if (item.count &gt;&#x3D; this.useCount) &#123; await item.page.close(); item.page &#x3D; await this.createPage(item.browser); item.count &#x3D; 0; &#125; item.used &#x3D; false; return ret; &#125; else &#123; &#x2F;&#x2F; 没有拿到空闲的page 临时新建一个用完关闭 let page &#x3D; await this.createPage(this.browsers[0].browser); try &#123; ret &#x3D; await func(page); &#125; catch (e) &#123; ret &#x3D; false; &#125; await page.close(); return ret; &#125; &#125; async _findFreePage() &#123; for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123; for (var k &#x3D; 0; k &lt; this.pageMax; k++) &#123; let item &#x3D; this.browsers[i].pages[k]; if (item.used &#x3D;&#x3D;&#x3D; false) &#123; if (item.page.isClosed()) &#123; item.page &#x3D; await this.createPage(this.browsers[i].browser); item.count &#x3D; 0; &#125; this.browsers[i].pages.push(this.browsers[i].pages.splice(k, 1)[0]); return item; &#125; &#125; &#125; return false; &#125; sleep (time) &#123; return new Promise((res, rej) &#x3D;&gt; setTimeout(res, time)) &#125;; async checkFree() &#123; for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123; for (var k &#x3D; 0; k &lt; this.pageMax; k++) &#123; if (this.browsers[i].pages[k].used) &#123; await this.sleep(1000); return this.checkFree(); &#125; &#125; &#125; &#125; async close() &#123; for (var i &#x3D; 0; i &lt; this.browserMax; i++) &#123; await this.browsers[i].browser.close(); &#125; &#125;&#125;module.exports &#x3D; Pool puppeteer做成一个服务，接口需要快速生成图片，往往在200ms就需要返回，通过配置连接池，可减少启动谷歌，打开新页面带来的时间消耗（基本400ms以上）,所以提升还是非常大的，另外连接池还能应对并发。 缺点就是：服务器内存占用无法释放 异常处理 浏览器或者页面都存在崩溃的情况，需要对这类情况进行处理，保证及时释放掉崩溃的程序占用的资源，缓解服务器压力。 GoogleBroswer.on(&#39;disconnected&#39;, this.closeBroswer); 浏览器提供了相应的监听方法，我们只需要控制好逻辑处理就行。 总结 puppeteer有谷歌作为后盾，技术实力可见一斑，社区支持基本够用 puppeteer作为生产图片,pdf等的技术方案要优于其他，具体小伙伴可以自行对比 功能强大，api支持度高，使用对前端友好 对大数据的生成任务，比较消耗服务器资源 文档介绍偏向入门，给人很强的信心，实际操作起来，步步受限","categories":[{"name":"FE","slug":"FE","permalink":"https://fox-z.github.io/categories/FE/"}],"tags":[{"name":"puppeteer","slug":"puppeteer","permalink":"https://fox-z.github.io/tags/puppeteer/"}]},{"title":"Hooks基本用法","slug":"Hooks","date":"2020-05-30T06:16:54.000Z","updated":"2020-09-10T11:55:54.125Z","comments":true,"path":"2020/05/30/Hooks/","link":"","permalink":"https://fox-z.github.io/2020/05/30/Hooks/","excerpt":"","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 hook规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。简单的讲：react依赖hook定义的顺序，以便在每一次重渲染时都能准确更新状态. 只在 React 函数中调用 Hook 在 React 的函数组件中调用 Hook在自定义 Hook 中调用其他 Hook useStateuseState主要用来定义可以影响视图的变量 参数：initState 两种类型(any || () =&gt; {})返回值：[a, setA] (数组且只有两个参数) 思考下为啥是一个数组？ 如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。 如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用： 示例： 123456789101112import &#123; useState &#125; from &#39;react&#39;function App() &#123; const [a, setA] &#x3D; useState(0); &#x2F;&#x2F; const [a, setA] &#x3D; useState(() &#x3D;&gt; 0); return ( &lt;&gt; &lt;div&gt;&#123;a&#125;&lt;&#x2F;div&gt; &lt;&#x2F;&gt; )&#125; 主要使用场景：定义组件内部的一些状态 useReducer参数：（reducerFunction, initState）返回值：[a, dispatchA] (数组且只有两个参数) useReducer和useState一样主要用来定义可以影响视图的变量useState底层用的还是useReducer，所以你任何时候可以使用useReducer代替useState 12345const [items, dispatch] &#x3D; useReducer((state, action) &#x3D;&gt; &#123; switch (action.type) &#123; &#x2F;&#x2F; do something with the action &#125;&#125;, []); 主要使用场景：在useState的基础上，useReducer多了在父子组件通讯上的功能，比如可以直接向子组件传递一个dispatch 而不是 回调函数，另外在处理复杂逻辑时显然useReducer显得更加优雅。 注意点 对于引用类型的数据，例如数组。useState和useReducer都是不可以直接对变量（a）进行操作的，必须切断引用关系，新值才会生效 解决方案：对于复杂数据类型 通用的方案是 immer use-immer, 使用useImmer替代useState 是更加合理的方案 qa: 当组件拥有多个 state 时，应该把多个 state 合并成一个 state ，还是把 state 切分成多个 state 变量？ 要么把所有 state 都放在同一个 useState 调用中，要么每一个字段都对应一个 useState 调用，这两方式都能跑通。 当你在这两个极端之间找到平衡，然后把相关 state 组合到几个独立的 state 变量时，组件就会更加的可读。如果 state 的逻辑开始变得复杂，我们推荐用 useReducer 来管理它，或使用自定义 Hook。 useEffect参数：(callback, []?)返回值：可选 (componentWillUnmount) useEffect 用来取代 componentDidMount , componentDidUpdate 和 componentWillUnmount。主要作用是当页面渲染后，进行一些副作用操作 副作用：访问 DOM，请求数据，定时器，订阅消息。 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。 每次 Render 都有自己的 Props 与 State可以认为每次 Render 的内容都会形成一个快照并保留下来，因此当状态变更而 Rerender 时，就形成了 N 个 Render 状态，而每个 Render 状态都拥有自己固定不变的 Props 与 State。 在每次点击时，count 只是一个不会变的常量，而且也不存在利用 Proxy 的双向绑定，只是一个常量存在于每次 Render 中。初始状态下 count 值为 0，而随着按钮被点击，在每次 Render 过程中，count 的值都会被固化为 1、2、3： 1234567891011121314151617181920212223&#x2F;&#x2F; During first renderfunction Counter() &#123; const count &#x3D; 0; &#x2F;&#x2F; Returned by useState() &#x2F;&#x2F; ... &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; After a click, our function is called againfunction Counter() &#123; const count &#x3D; 1; &#x2F;&#x2F; Returned by useState() &#x2F;&#x2F; ... &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;; &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; After another click, our function is called againfunction Counter() &#123; const count &#x3D; 2; &#x2F;&#x2F; Returned by useState() &#x2F;&#x2F; ... &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;; &#x2F;&#x2F; ...&#125; 几个用法 useEffect当作componentDidMount用 123456789useEffect(() &#x3D;&gt; &#123; const fetchData &#x3D; async () &#x3D;&gt; &#123; const result &#x3D; await axios( &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;, ); setData(result.data); &#125;; fetchData();&#125;, []); useEffect当作componentDidMount, componentDidUpdate用 123456789useEffect(() &#x3D;&gt; &#123; const fetchData &#x3D; async () &#x3D;&gt; &#123; const result &#x3D; await axios( &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;, ); setData(result.data); &#125;; fetchData();&#125;, [page]); useEffect当作componentDidMount, componentDidUpdate,componentWillUnmount用 12345678910111213useEffect(() &#x3D;&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); &#x2F;&#x2F; Specify how to clean up after this effect: return function cleanup() &#123; &#x2F;&#x2F; 清除订阅 ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, []);&#x2F;&#x2F; 清除订阅在每次渲染都会执行，以确保老的视图不会对新视图造成副作用 性能优化建议： 依赖项数组控制着 useEffect 的执行 如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 useEffect 不能接收 async 作为回调函数，useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise 在 useEffect 中调用用函数时，要把该函数在 useEffect 中申明，不能放到外部申明，然后再在 useEffect 中调用，你会想要在 effect 内部 去声明它所需要的函数。 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值 useLayoutEffect useLayoutEffect与useEffect作用比较相同 区别点在于执行的时机 useEffect在全部渲染完毕后才会执行，useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行 可以使用它来读取 DOM 布局并同步触发重渲染 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect 在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被同步刷新 尽可能使用标准的 useEffect 以避免阻塞视图更新 1234567891011121314151617function LayoutEffect() &#123; const [color, setColor] &#x3D; useState(&#39;red&#39;); useLayoutEffect(() &#x3D;&gt; &#123; alert(color); &#x2F;&#x2F; 阻塞了渲染 &#125;); useEffect(() &#x3D;&gt; &#123; console.log(&#39;color&#39;, color); &#125;); return ( &lt;&gt; &lt;div id&#x3D;&quot;myDiv&quot; style&#x3D;&#123;&#123; background: color &#125;&#125;&gt;颜色&lt;&#x2F;div&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;red&#39;)&#125;&gt;红&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;yellow&#39;)&#125;&gt;黄&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setColor(&#39;blue&#39;)&#125;&gt;蓝&lt;&#x2F;button&gt; &lt;&#x2F;&gt; );&#125; useCallback参数：(callback, []?)返回值: function 接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新 第二个参数为依赖项，如果没有则每次都会执行返回值函数，为空数组，组件初始化的时候执行一次，后续 update 则取缓存里的，数组有依赖项，则在依赖项变更时触发useCallback。所以为了更好的性能，务必指定第二个参数 主要应用场景：父组件给子组件绑定方法，若非使用useCallback，则子组件在每次父组件render的时候都会重新渲染，推荐子组件搭配 React.memo 高阶函数一起使用。 useMemo参数：(callback, []?)返回值: any 把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的 主要应用场景：熟悉Vue的同学可以把这个当作computed计算属性来理解，因此callback中最好指定return 项 useCallback 与 useMemo 的异同点 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps), 最终的返回值都是一个 test 的memoized版本 useMemo更适合计算属性的场景，昂贵的计算 （购物车计算价格数量等） useCallback更适合给组件绑定方法 useCallback返回的只能是函数，useMemo能返回多种类型 useRef参数：initState返回值：{ current: initState } useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initState）。返回的 ref 对象在组件的整个生命周期内保持不变。 ref用来访问DOM，useRef同样也可以，但是useRef能做更多可变值的保存。用useRef申明的值和一个普通的js对象的区别在于useRef每次都返回同一个ref对象，而不会重新创建。 主要应用场景： 组件内部一次渲染需要用到另一个state值，但此时state值永远都是初始值，useRef可以用来记录每一次更新后的state，方便在其他渲染逻辑中能访问到最新值 记录组件中的某一个元素 父组件调用子组件的方法，通常配合forwardRef + useImperativeHandle来使用，使用FancyInput的组件中绑定ref就可以访问到focus方法， &lt;FancyInput ref={inputRef} /&gt;父组件中调用 inputRef.current.focus() 示例如下 12345678910function FancyInput(props, ref) &#123; const inputRef &#x3D; useRef(); useImperativeHandle(ref, () &#x3D;&gt; (&#123; focus: () &#x3D;&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref&#x3D;&#123;inputRef&#125; ... &#x2F;&gt;;&#125;FancyInput &#x3D; forwardRef(FancyInput); useContextconst MyContext = React.createContext() 参数：context对象（MyContext）返回值：传入context对象的值 context可以在跨多个层级组件之间通讯，当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。 调用了 useContext 的组件总会在 context 值变化时重新渲染，即使使用了React.memo。 子孙组件通过调用 useContext(MyContext) 可以拿到上层组件中的 context 的 value useReducer + useContext 综合运用案例12345678910111213141516171819202122232425262728293031323334&lt;!-- 祖组件 --&gt;const TodosDispatch &#x3D; React.createContext(null);function todosReducer(state, action) &#123; switch (action.type) &#123; case: &#39;&#39;: &#x2F;&#x2F; do something break; &#125;&#125;function TodosApp() &#123; &#x2F;&#x2F; 提示：&#96;dispatch&#96; 不会在重新渲染之间变化 const [todos, dispatch] &#x3D; useReducer(todosReducer); return ( &lt;TodosDispatch.Provider value&#x3D;&#123;dispatch&#125;&gt; &lt;DeepTree todos&#x3D;&#123;todos&#125; &#x2F;&gt; &lt;&#x2F;TodosDispatch.Provider&gt; );&#125;&lt;!-- 子孙组件 --&gt;function DeepChild(props) &#123; &#x2F;&#x2F; 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。 const dispatch &#x3D; useContext(TodosDispatch); function handleClick() &#123; dispatch(&#123; type: &#39;add&#39;, text: &#39;hello&#39; &#125;); &#125; return ( &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Add todo&lt;&#x2F;button&gt; );&#125; 语法检查我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。示例如下： 12345678&#123; &quot;plugins&quot;: [&quot;react-hooks&quot;], &#x2F;&#x2F; ... &quot;rules&quot;: &#123; &quot;react-hooks&#x2F;rules-of-hooks&quot;: &#39;error&#39;,&#x2F;&#x2F; 检查 Hook 的规则 &quot;react-hooks&#x2F;exhaustive-deps&quot;: &#39;warn&#39; &#x2F;&#x2F; 检查 effect 的依赖 &#125;&#125; 本文参考链接1.官方文档：https://react.docschina.org/docs/hooks-reference.html2.掘金链接地址： https://juejin.im/post/5de38c76e51d455f9b335eff https://juejin.im/post/5c9827745188250ff85afe50 https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d","categories":[{"name":"FE","slug":"FE","permalink":"https://fox-z.github.io/categories/FE/"}],"tags":[{"name":"React","slug":"React","permalink":"https://fox-z.github.io/tags/React/"}]},{"title":"小程序输入框问题解决方案(Taro)","slug":"微信小程序输入框问题解决方案","date":"2020-05-20T06:16:54.000Z","updated":"2020-09-10T11:56:06.605Z","comments":true,"path":"2020/05/20/微信小程序输入框问题解决方案/","link":"","permalink":"https://fox-z.github.io/2020/05/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"Taro小程序最近做的比较多的，业务涉及到都是表单相关组件，吃了不少苦头，于是就有了这篇文章，记录下经验，也希望能帮到你。 本文的所有场景都是基于页面中有大量input,textarea等文本输入组件 你不知道的input input在聚焦focus时表现为原生组件，层级最高，脱离page限制，设置z-index都无法改变 input默认有z-index: [1-2) 的层级，这个很多人都踩过坑 举个例子：某一个页面有大量输入框，底部有个悬浮的按钮btn, 固定定位的。当滑动页面 使btn覆盖在input上时，点击btn会发现注册在btn上的事件失效，点了没反应… ，如果这时脑子里想到的全是原生组件层级最高，那么你就进坑了，（没错，说的就是我）,然后就走向cover-view实现btn这条不归路，cover-view会定位错乱，滑动之后btn就飞了。 123456789101112131415161718192021222324252627&#x2F;&#x2F; 贴点代码 方便理解（错误示例）&lt;Input className&#x3D;&quot;ipt&quot; type&#x3D;&quot;number&quot; placeholderClass&#x3D;&quot;ipt-place&quot; value&#x3D;&#123;phone&#125; onInput&#x3D;&#123;this.phoneChange&#125; placeholder&#x3D;&quot;请输入手机号&quot;&gt;&lt;&#x2F;Input&gt;&#x2F;&#x2F; 按钮&lt;View className&#x3D;&quot;btn-wrap&quot;&gt; &lt;CoverView className&#x3D;&quot;btn&quot; onClick&#x3D;&#123;this.confirm&#125; &gt;保存&lt;&#x2F;CoverView&gt;&lt;&#x2F;View&gt;&#x2F;&#x2F; css.btn-wrap&#123; position: fixed; bottom: 0; left: 0; z-index: 1&#125; 显然解决思路错了，实际上结合上面第一条和第二条就知道错在哪里了，input没有聚焦的时候不是原生组件。我思路错的原因在于我开始的时候btn-wrap的z-index设置为1了，以为比页面元素高，于是当按钮覆盖input的时候，input的层级在btn之上, 这就是奇怪的地方，同样是1，后设置zIndex的元素应该在上面，但是这个例子中在开发工具和真机上都表现出input在上面的情况。当我把btn-wrap的zIndex设置为2的时候表现正常了，按钮在上，点击也正常了。所以我得出结论，input有1-2的层级。底部按钮不需要使用cover-view,用普通的view即可。 input类型为number在一些真机上会出现 聚焦时页面白屏，输入时闪烁的问题，替代方案是用digit,text, 之后结果自己处理下（正则限制） TextArea的一些骚操作 原生组件，没有同层渲染，层级最高，页面中如果有弹窗就要注意了，textarea会覆盖在弹窗之上，不管你的弹窗层级多高。鉴于这种情况，弹窗，自定义头部等一切高于页面本身元素的组件建议用cover-view和cover-img搭配实现。 TextArea当作按钮，没错，你没听错 说说为啥用TextArea做按钮，当一个全是Textarea输入框的时候，底部有悬浮按钮，按钮上绑定了事件handle，想象一下。这时候底部按钮就不能用普通的View了，层级原因，鉴于cover-view定位有问题的情况，我尝试了canvas，input，textarea，最后选择了textarea(disable)这种做按钮，并设置了zIndex，canvas 高版本sdk中为同层渲染，input也是。只能textarea了，以彼之道还施彼身。这样就覆盖在页面中的textarea之上了。 以为textarea(disable)加个样式就实现了？？？ 上真机上一看，ios上按钮正常显示，点击按钮handle事件也执行了，别激动 安卓上看看，按钮正常显示，点击，没反应。。。原因是disable导致的，于是乎我又开始拿出我的钻地弹了，各种尝试，终于发现textarea设置了padding有效，就是点击padding的区域，事件handle能执行，于是乎我设置padding充满了整个textarea，让按钮每一个角落都能点击。 现在才说实现了 ui + 点击。（测试了部分机型，可以的，如果有其他机型不行，告诉我。当然如果原生textarea实现有变动，可能就用不了） 12345678910&lt;Textarea disabled fixed disableDefaultPadding&gt;&lt;&#x2F;Textarea&gt;textarea&#123; height: 40px; padding: 20px;&#125; cover-view &amp;&amp; cover-img组件使用注意事项 以下统称cover组件 cover组件表现层级最高，cover-view 在小程序中是比较特殊的组件，与 view 的最大区别在于，它能覆盖在原生组件 map、video、canvas、camera 之上，且只能嵌套 cover-view， button 和 cover-image。如果说textarea是顶楼，那么cover就是天台，没有比cover组件层级更高的组件了。 cover-view 单边border设置无效真机上表现为全border，所以需要处理，思路有两种 再写一个cover-view高度为1，背景色设置为边框色 让ui切个边框图，写一个cover-img实现 cover-view在fixed的盒子中，无法正常定位，会随页面的滚动而滚动 同样是底部按钮悬浮的场景 这种情况是基础库低于1.9.90版本出现的，由于最外层 cover-view 不支持 position: fixed; 所以最外层盒子采用 view 定位 position: fixed;基础库 1.9.90 起最外层 cover-view 支持 position: fixed, 但是在部分机型上仍然会出现 键盘弹起，滑动页面 场景下 定位错乱的问题，目前还未解决，但是有替代方案textarea。","categories":[{"name":"FE","slug":"FE","permalink":"https://fox-z.github.io/categories/FE/"}],"tags":[{"name":"miniprogram","slug":"miniprogram","permalink":"https://fox-z.github.io/tags/miniprogram/"}]},{"title":"Hexo基本命令","slug":"Hexo基本命令","date":"2019-09-10T02:41:37.000Z","updated":"2020-09-10T11:57:04.182Z","comments":true,"path":"2019/09/10/Hexo基本命令/","link":"","permalink":"https://fox-z.github.io/2019/09/10/Hexo%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"tools","slug":"tools","permalink":"https://fox-z.github.io/categories/tools/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://fox-z.github.io/tags/Hexo/"}]}]}